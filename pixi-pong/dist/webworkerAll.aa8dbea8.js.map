{"mappings":"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","sources":["<anon>","node_modules/pixi.js/lib/environment-webworker/webworkerAll.mjs","node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs","node_modules/pixi.js/src/rendering/renderers/shared/state/State.ts","node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs","node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts","node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs","node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/TexturePool.ts","node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts","node_modules/pixi.js/lib/rendering/renderers/shared/texture/CanvasPool.mjs","node_modules/pixi.js/src/rendering/renderers/shared/texture/CanvasPool.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire94c2\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"danRq\", function(module, exports) {\nparcelRequire(\"xtmW0\");\nparcelRequire(\"4RJM2\");\nparcelRequire(\"7dx1H\");\nparcelRequire(\"bqs0D\");\nparcelRequire(\"7rvGX\");\nparcelRequire(\"hOtIT\");\nparcelRequire(\"72HgH\");\nparcelRequire(\"gltHT\");\nparcelRequire(\"7t4bH\");\nparcelRequire(\"jbAJT\");\nparcelRequire(\"3WtzG\");\nparcelRequire(\"3v0XG\");\n\"use strict\";\n\n});\n\nparcelRegister(\"2Aebl\", function(module, exports) {\n\n$parcel$export(module.exports, \"State\", () => $f68a91b4254cec58$export$7254cc27399e90bd);\n\"use strict\";\nconst $f68a91b4254cec58$var$blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    \"normal-npm\": 6,\n    \"add-npm\": 7,\n    \"screen-npm\": 8,\n    min: 9,\n    max: 10\n};\nconst $f68a91b4254cec58$var$BLEND = 0;\nconst $f68a91b4254cec58$var$OFFSET = 1;\nconst $f68a91b4254cec58$var$CULLING = 2;\nconst $f68a91b4254cec58$var$DEPTH_TEST = 3;\nconst $f68a91b4254cec58$var$WINDING = 4;\nconst $f68a91b4254cec58$var$DEPTH_MASK = 5;\nconst $f68a91b4254cec58$var$_State = class _State {\n    constructor(){\n        this.data = 0;\n        this.blendMode = \"normal\";\n        this.polygonOffset = 0;\n        this.blend = true;\n        this.depthMask = true;\n    }\n    /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */ get blend() {\n        return !!(this.data & 1 << $f68a91b4254cec58$var$BLEND);\n    }\n    set blend(value) {\n        if (!!(this.data & 1 << $f68a91b4254cec58$var$BLEND) !== value) this.data ^= 1 << $f68a91b4254cec58$var$BLEND;\n    }\n    /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */ get offsets() {\n        return !!(this.data & 1 << $f68a91b4254cec58$var$OFFSET);\n    }\n    set offsets(value) {\n        if (!!(this.data & 1 << $f68a91b4254cec58$var$OFFSET) !== value) this.data ^= 1 << $f68a91b4254cec58$var$OFFSET;\n    }\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */ set cullMode(value) {\n        if (value === \"none\") {\n            this.culling = false;\n            return;\n        }\n        this.culling = true;\n        this.clockwiseFrontFace = value === \"front\";\n    }\n    get cullMode() {\n        if (!this.culling) return \"none\";\n        return this.clockwiseFrontFace ? \"front\" : \"back\";\n    }\n    /**\n   * Activates culling of polygons.\n   * @default false\n   */ get culling() {\n        return !!(this.data & 1 << $f68a91b4254cec58$var$CULLING);\n    }\n    set culling(value) {\n        if (!!(this.data & 1 << $f68a91b4254cec58$var$CULLING) !== value) this.data ^= 1 << $f68a91b4254cec58$var$CULLING;\n    }\n    /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */ get depthTest() {\n        return !!(this.data & 1 << $f68a91b4254cec58$var$DEPTH_TEST);\n    }\n    set depthTest(value) {\n        if (!!(this.data & 1 << $f68a91b4254cec58$var$DEPTH_TEST) !== value) this.data ^= 1 << $f68a91b4254cec58$var$DEPTH_TEST;\n    }\n    /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */ get depthMask() {\n        return !!(this.data & 1 << $f68a91b4254cec58$var$DEPTH_MASK);\n    }\n    set depthMask(value) {\n        if (!!(this.data & 1 << $f68a91b4254cec58$var$DEPTH_MASK) !== value) this.data ^= 1 << $f68a91b4254cec58$var$DEPTH_MASK;\n    }\n    /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */ get clockwiseFrontFace() {\n        return !!(this.data & 1 << $f68a91b4254cec58$var$WINDING);\n    }\n    set clockwiseFrontFace(value) {\n        if (!!(this.data & 1 << $f68a91b4254cec58$var$WINDING) !== value) this.data ^= 1 << $f68a91b4254cec58$var$WINDING;\n    }\n    /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */ get blendMode() {\n        return this._blendMode;\n    }\n    set blendMode(value) {\n        this.blend = value !== \"none\";\n        this._blendMode = value;\n        this._blendModeId = $f68a91b4254cec58$var$blendModeIds[value] || 0;\n    }\n    /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */ get polygonOffset() {\n        return this._polygonOffset;\n    }\n    set polygonOffset(value) {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n    toString() {\n        return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n    }\n    /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */ static for2d() {\n        const state = new _State();\n        state.depthTest = false;\n        state.blend = true;\n        return state;\n    }\n};\n$f68a91b4254cec58$var$_State.default2d = $f68a91b4254cec58$var$_State.for2d();\nlet $f68a91b4254cec58$export$7254cc27399e90bd = $f68a91b4254cec58$var$_State;\n\n});\n\nparcelRegister(\"6B0gZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"color32BitToUniform\", () => $67025a23fd381e5c$export$2c68e848c5b81f5);\n\"use strict\";\nfunction $67025a23fd381e5c$export$d13a52631f102a23(rgb, alpha, out, offset) {\n    out[offset++] = (rgb >> 16 & 255) / 255;\n    out[offset++] = (rgb >> 8 & 255) / 255;\n    out[offset++] = (rgb & 255) / 255;\n    out[offset++] = alpha;\n}\nfunction $67025a23fd381e5c$export$2c68e848c5b81f5(abgr, out, offset) {\n    const alpha = (abgr >> 24 & 255) / 255;\n    out[offset++] = (abgr & 255) / 255 * alpha;\n    out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n    out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n    out[offset++] = alpha;\n}\n\n});\n\nparcelRegister(\"6qNFd\", function(module, exports) {\n\n$parcel$export(module.exports, \"BatchableSprite\", () => $745046e2c487719c$export$fe4bdc7069ee0b9c);\n\"use strict\";\nclass $745046e2c487719c$export$fe4bdc7069ee0b9c {\n    constructor(){\n        this.batcherName = \"default\";\n        // batch specific..\n        this.attributeSize = 4;\n        this.indexSize = 6;\n        this.packAsQuad = true;\n        this.roundPixels = 0;\n        this._attributeStart = 0;\n        // location in the buffer\n        this._batcher = null;\n        this._batch = null;\n    }\n    get blendMode() {\n        return this.renderable.groupBlendMode;\n    }\n    get color() {\n        return this.renderable.groupColorAlpha;\n    }\n    reset() {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n}\n\n});\n\nparcelRegister(\"3Xbp7\", function(module, exports) {\n\n$parcel$export(module.exports, \"TexturePool\", () => $0b9fa50ced13ccd0$export$686d8ddcd5ee6cd2);\n\nvar $NbSCN = parcelRequire(\"NbSCN\");\n\nvar $iA5fe = parcelRequire(\"iA5fe\");\n\nvar $bLlTJ = parcelRequire(\"bLlTJ\");\n\"use strict\";\nlet $0b9fa50ced13ccd0$var$count = 0;\nclass $0b9fa50ced13ccd0$export$f5c6a2d8ed21d1d {\n    /**\n   * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n   * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n   */ constructor(textureOptions){\n        this._poolKeyHash = /* @__PURE__ */ Object.create(null);\n        this._texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n    }\n    /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   * @param antialias\n   */ createTexture(pixelWidth, pixelHeight, antialias) {\n        const textureSource = new (0, $iA5fe.TextureSource)({\n            ...this.textureOptions,\n            width: pixelWidth,\n            height: pixelHeight,\n            resolution: 1,\n            antialias: antialias,\n            autoGarbageCollect: true\n        });\n        return new (0, $bLlTJ.Texture)({\n            source: textureSource,\n            label: `texturePool_${$0b9fa50ced13ccd0$var$count++}`\n        });\n    }\n    /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param frameWidth - The minimum width of the render texture.\n   * @param frameHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @param antialias\n   * @returns The new render texture.\n   */ getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {\n        let po2Width = Math.ceil(frameWidth * resolution - 1e-6);\n        let po2Height = Math.ceil(frameHeight * resolution - 1e-6);\n        po2Width = (0, $NbSCN.nextPow2)(po2Width);\n        po2Height = (0, $NbSCN.nextPow2)(po2Height);\n        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n        if (!this._texturePool[key]) this._texturePool[key] = [];\n        let texture = this._texturePool[key].pop();\n        if (!texture) texture = this.createTexture(po2Width, po2Height, antialias);\n        texture.source._resolution = resolution;\n        texture.source.width = po2Width / resolution;\n        texture.source.height = po2Height / resolution;\n        texture.source.pixelWidth = po2Width;\n        texture.source.pixelHeight = po2Height;\n        texture.frame.x = 0;\n        texture.frame.y = 0;\n        texture.frame.width = frameWidth;\n        texture.frame.height = frameHeight;\n        texture.updateUvs();\n        this._poolKeyHash[texture.uid] = key;\n        return texture;\n    }\n    /**\n   * Gets extra texture of the same size as input renderTexture\n   * @param texture - The texture to check what size it is.\n   * @param antialias - Whether to use antialias.\n   * @returns A texture that is a power of two\n   */ getSameSizeTexture(texture, antialias = false) {\n        const source = texture.source;\n        return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n    }\n    /**\n   * Place a render texture back into the pool.\n   * @param renderTexture - The renderTexture to free\n   */ returnTexture(renderTexture) {\n        const key = this._poolKeyHash[renderTexture.uid];\n        this._texturePool[key].push(renderTexture);\n    }\n    /**\n   * Clears the pool.\n   * @param destroyTextures - Destroy all stored textures.\n   */ clear(destroyTextures) {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures) for(const i in this._texturePool){\n            const textures = this._texturePool[i];\n            if (textures) for(let j = 0; j < textures.length; j++)textures[j].destroy(true);\n        }\n        this._texturePool = {};\n    }\n}\nconst $0b9fa50ced13ccd0$export$686d8ddcd5ee6cd2 = new $0b9fa50ced13ccd0$export$f5c6a2d8ed21d1d();\n\n});\n\nparcelRegister(\"huPGn\", function(module, exports) {\n\n$parcel$export(module.exports, \"localUniformBit\", () => $0f993a3eb7a96f7d$export$1723ac05bd5e9336);\n$parcel$export(module.exports, \"localUniformBitGroup2\", () => $0f993a3eb7a96f7d$export$adb0f80794f644d9);\n$parcel$export(module.exports, \"localUniformBitGl\", () => $0f993a3eb7a96f7d$export$36099520d0a716a);\n\"use strict\";\nconst $0f993a3eb7a96f7d$export$1723ac05bd5e9336 = {\n    name: \"local-uniform-bit\",\n    vertex: {\n        header: /* wgsl */ `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */ `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */ `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    }\n};\nconst $0f993a3eb7a96f7d$export$adb0f80794f644d9 = {\n    ...$0f993a3eb7a96f7d$export$1723ac05bd5e9336,\n    vertex: {\n        ...$0f993a3eb7a96f7d$export$1723ac05bd5e9336.vertex,\n        // replace the group!\n        header: $0f993a3eb7a96f7d$export$1723ac05bd5e9336.vertex.header.replace(\"group(1)\", \"group(2)\")\n    }\n};\nconst $0f993a3eb7a96f7d$export$36099520d0a716a = {\n    name: \"local-uniform-bit\",\n    vertex: {\n        header: /* glsl */ `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */ `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */ `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    }\n};\n\n});\n\nparcelRegister(\"6RGCN\", function(module, exports) {\n\n$parcel$export(module.exports, \"CanvasPool\", () => $cb3b5b020b2ab749$export$e56d0a06781accc9);\n\nvar $iCGeI = parcelRequire(\"iCGeI\");\n\nvar $NbSCN = parcelRequire(\"NbSCN\");\n\"use strict\";\nclass $cb3b5b020b2ab749$export$62d9f0b8aada09d7 {\n    constructor(canvasOptions){\n        this._canvasPool = /* @__PURE__ */ Object.create(null);\n        this.canvasOptions = canvasOptions || {};\n        this.enableFullScreen = false;\n    }\n    /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   */ _createCanvasAndContext(pixelWidth, pixelHeight) {\n        const canvas = (0, $iCGeI.DOMAdapter).get().createCanvas();\n        canvas.width = pixelWidth;\n        canvas.height = pixelHeight;\n        const context = canvas.getContext(\"2d\");\n        return {\n            canvas: canvas,\n            context: context\n        };\n    }\n    /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture.\n   * @param minHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @returns The new render texture.\n   */ getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {\n        minWidth = Math.ceil(minWidth * resolution - 1e-6);\n        minHeight = Math.ceil(minHeight * resolution - 1e-6);\n        minWidth = (0, $NbSCN.nextPow2)(minWidth);\n        minHeight = (0, $NbSCN.nextPow2)(minHeight);\n        const key = (minWidth << 17) + (minHeight << 1);\n        if (!this._canvasPool[key]) this._canvasPool[key] = [];\n        let canvasAndContext = this._canvasPool[key].pop();\n        if (!canvasAndContext) canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n        return canvasAndContext;\n    }\n    /**\n   * Place a render texture back into the pool.\n   * @param canvasAndContext\n   */ returnCanvasAndContext(canvasAndContext) {\n        const canvas = canvasAndContext.canvas;\n        const { width: width, height: height } = canvas;\n        const key = (width << 17) + (height << 1);\n        canvasAndContext.context.clearRect(0, 0, width, height);\n        this._canvasPool[key].push(canvasAndContext);\n    }\n    clear() {\n        this._canvasPool = {};\n    }\n}\nconst $cb3b5b020b2ab749$export$e56d0a06781accc9 = new $cb3b5b020b2ab749$export$62d9f0b8aada09d7();\n\n});\n\n\n//# sourceMappingURL=webworkerAll.aa8dbea8.js.map\n","import '../app/init.mjs';\nimport '../spritesheet/init.mjs';\nimport '../rendering/init.mjs';\nimport '../scene/graphics/init.mjs';\nimport '../scene/mesh/init.mjs';\nimport '../scene/particle-container/init.mjs';\nimport '../scene/text/init.mjs';\nimport '../scene/text-bitmap/init.mjs';\nimport '../scene/text-html/init.mjs';\nimport '../scene/sprite-tiling/init.mjs';\nimport '../scene/sprite-nine-slice/init.mjs';\nimport '../filters/init.mjs';\n\n\"use strict\";\n//# sourceMappingURL=webworkerAll.mjs.map\n","\"use strict\";\nconst blendModeIds = {\n  normal: 0,\n  add: 1,\n  multiply: 2,\n  screen: 3,\n  overlay: 4,\n  erase: 5,\n  \"normal-npm\": 6,\n  \"add-npm\": 7,\n  \"screen-npm\": 8,\n  min: 9,\n  max: 10\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _State = class _State {\n  constructor() {\n    this.data = 0;\n    this.blendMode = \"normal\";\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    if (!!(this.data & 1 << BLEND) !== value) {\n      this.data ^= 1 << BLEND;\n    }\n  }\n  /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    if (!!(this.data & 1 << OFFSET) !== value) {\n      this.data ^= 1 << OFFSET;\n    }\n  }\n  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n  set cullMode(value) {\n    if (value === \"none\") {\n      this.culling = false;\n      return;\n    }\n    this.culling = true;\n    this.clockwiseFrontFace = value === \"front\";\n  }\n  get cullMode() {\n    if (!this.culling) {\n      return \"none\";\n    }\n    return this.clockwiseFrontFace ? \"front\" : \"back\";\n  }\n  /**\n   * Activates culling of polygons.\n   * @default false\n   */\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    if (!!(this.data & 1 << CULLING) !== value) {\n      this.data ^= 1 << CULLING;\n    }\n  }\n  /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    if (!!(this.data & 1 << DEPTH_TEST) !== value) {\n      this.data ^= 1 << DEPTH_TEST;\n    }\n  }\n  /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    if (!!(this.data & 1 << DEPTH_MASK) !== value) {\n      this.data ^= 1 << DEPTH_MASK;\n    }\n  }\n  /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    if (!!(this.data & 1 << WINDING) !== value) {\n      this.data ^= 1 << WINDING;\n    }\n  }\n  /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== \"none\";\n    this._blendMode = value;\n    this._blendModeId = blendModeIds[value] || 0;\n  }\n  /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value;\n    this._polygonOffset = value;\n  }\n  toString() {\n    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n  }\n  /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */\n  static for2d() {\n    const state = new _State();\n    state.depthTest = false;\n    state.blend = true;\n    return state;\n  }\n};\n_State.default2d = _State.for2d();\nlet State = _State;\n\nexport { State };\n//# sourceMappingURL=State.mjs.map\n","/* eslint-disable max-len */\nimport type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n    min: 9,\n    max: 10,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link StateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @memberof rendering\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n","\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexport { color32BitToUniform, colorToUniform };\n//# sourceMappingURL=colorToUniform.mjs.map\n","export function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n","\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    this.batcherName = \"default\";\n    // batch specific..\n    this.attributeSize = 4;\n    this.indexSize = 6;\n    this.packAsQuad = true;\n    this.roundPixels = 0;\n    this._attributeStart = 0;\n    // location in the buffer\n    this._batcher = null;\n    this._batch = null;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  get color() {\n    return this.renderable.groupColorAlpha;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this._batcher = null;\n    this._batch = null;\n    this.bounds = null;\n  }\n}\n\nexport { BatchableSprite };\n//# sourceMappingURL=BatchableSprite.mjs.map\n","import type { Matrix } from '../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableQuadElement } from '../../rendering/batcher/shared/DefaultBatcher';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { ViewContainer } from '../view/ViewContainer';\n\n/**\n * A batchable sprite object.\n * @ignore\n */\nexport class BatchableSprite implements DefaultBatchableQuadElement\n{\n    public batcherName = 'default';\n\n    // batch specific..\n    public readonly attributeSize = 4;\n    public readonly indexSize = 6;\n    public readonly packAsQuad = true;\n\n    public transform: Matrix;\n\n    public renderable: ViewContainer;\n    public texture: Texture;\n    public bounds: BoundsData;\n\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart = 0; // location in the buffer\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n    get color() { return this.renderable.groupColorAlpha; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n}\n","import { nextPow2 } from '../../../../maths/misc/pow2.mjs';\nimport { TextureSource } from './sources/TextureSource.mjs';\nimport { Texture } from './Texture.mjs';\n\n\"use strict\";\nlet count = 0;\nclass TexturePoolClass {\n  /**\n   * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n   * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n   */\n  constructor(textureOptions) {\n    this._poolKeyHash = /* @__PURE__ */ Object.create(null);\n    this._texturePool = {};\n    this.textureOptions = textureOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   * @param antialias\n   */\n  createTexture(pixelWidth, pixelHeight, antialias) {\n    const textureSource = new TextureSource({\n      ...this.textureOptions,\n      width: pixelWidth,\n      height: pixelHeight,\n      resolution: 1,\n      antialias,\n      autoGarbageCollect: true\n    });\n    return new Texture({\n      source: textureSource,\n      label: `texturePool_${count++}`\n    });\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param frameWidth - The minimum width of the render texture.\n   * @param frameHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @param antialias\n   * @returns The new render texture.\n   */\n  getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {\n    let po2Width = Math.ceil(frameWidth * resolution - 1e-6);\n    let po2Height = Math.ceil(frameHeight * resolution - 1e-6);\n    po2Width = nextPow2(po2Width);\n    po2Height = nextPow2(po2Height);\n    const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n    if (!this._texturePool[key]) {\n      this._texturePool[key] = [];\n    }\n    let texture = this._texturePool[key].pop();\n    if (!texture) {\n      texture = this.createTexture(po2Width, po2Height, antialias);\n    }\n    texture.source._resolution = resolution;\n    texture.source.width = po2Width / resolution;\n    texture.source.height = po2Height / resolution;\n    texture.source.pixelWidth = po2Width;\n    texture.source.pixelHeight = po2Height;\n    texture.frame.x = 0;\n    texture.frame.y = 0;\n    texture.frame.width = frameWidth;\n    texture.frame.height = frameHeight;\n    texture.updateUvs();\n    this._poolKeyHash[texture.uid] = key;\n    return texture;\n  }\n  /**\n   * Gets extra texture of the same size as input renderTexture\n   * @param texture - The texture to check what size it is.\n   * @param antialias - Whether to use antialias.\n   * @returns A texture that is a power of two\n   */\n  getSameSizeTexture(texture, antialias = false) {\n    const source = texture.source;\n    return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param renderTexture - The renderTexture to free\n   */\n  returnTexture(renderTexture) {\n    const key = this._poolKeyHash[renderTexture.uid];\n    this._texturePool[key].push(renderTexture);\n  }\n  /**\n   * Clears the pool.\n   * @param destroyTextures - Destroy all stored textures.\n   */\n  clear(destroyTextures) {\n    destroyTextures = destroyTextures !== false;\n    if (destroyTextures) {\n      for (const i in this._texturePool) {\n        const textures = this._texturePool[i];\n        if (textures) {\n          for (let j = 0; j < textures.length; j++) {\n            textures[j].destroy(true);\n          }\n        }\n      }\n    }\n    this._texturePool = {};\n  }\n}\nconst TexturePool = new TexturePoolClass();\n\nexport { TexturePool, TexturePoolClass };\n//# sourceMappingURL=TexturePool.mjs.map\n","import { nextPow2 } from '../../../../maths/misc/pow2';\nimport { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\nlet count = 0;\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in default pool\n * @memberof rendering\n * @name TexturePool\n */\nexport class TexturePoolClass\n{\n    /** The default options for texture pool */\n    public textureOptions: TextureSourceOptions;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n\n    private _texturePool: {[x in string | number]: Texture[]};\n    private _poolKeyHash: Record<number, number> = Object.create(null);\n\n    /**\n     * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n     * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n     */\n    constructor(textureOptions?: TextureSourceOptions)\n    {\n        this._texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     * @param antialias\n     */\n    public createTexture(pixelWidth: number, pixelHeight: number, antialias: boolean): Texture\n    {\n        const textureSource = new TextureSource({\n            ...this.textureOptions,\n\n            width: pixelWidth,\n            height: pixelHeight,\n            resolution: 1,\n            antialias,\n            autoGarbageCollect: true,\n        });\n\n        return new Texture({\n            source: textureSource,\n            label: `texturePool_${count++}`,\n        });\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param frameWidth - The minimum width of the render texture.\n     * @param frameHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @param antialias\n     * @returns The new render texture.\n     */\n    public getOptimalTexture(frameWidth: number, frameHeight: number, resolution = 1, antialias: boolean): Texture\n    {\n        let po2Width = Math.ceil((frameWidth * resolution) - 1e-6);\n        let po2Height = Math.ceil((frameHeight * resolution) - 1e-6);\n\n        po2Width = nextPow2(po2Width);\n        po2Height = nextPow2(po2Height);\n\n        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n\n        if (!this._texturePool[key])\n        {\n            this._texturePool[key] = [];\n        }\n\n        let texture = this._texturePool[key].pop();\n\n        if (!texture)\n        {\n            texture = this.createTexture(po2Width, po2Height, antialias);\n        }\n\n        texture.source._resolution = resolution;\n        texture.source.width = po2Width / resolution;\n        texture.source.height = po2Height / resolution;\n        texture.source.pixelWidth = po2Width;\n        texture.source.pixelHeight = po2Height;\n\n        // fit the layout to the requested original size\n        texture.frame.x = 0;\n        texture.frame.y = 0;\n        texture.frame.width = frameWidth;\n        texture.frame.height = frameHeight;\n\n        texture.updateUvs();\n\n        this._poolKeyHash[texture.uid] = key;\n\n        return texture;\n    }\n\n    /**\n     * Gets extra texture of the same size as input renderTexture\n     * @param texture - The texture to check what size it is.\n     * @param antialias - Whether to use antialias.\n     * @returns A texture that is a power of two\n     */\n    public getSameSizeTexture(texture: Texture, antialias = false)\n    {\n        const source = texture.source;\n\n        return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param renderTexture - The renderTexture to free\n     */\n    public returnTexture(renderTexture: Texture): void\n    {\n        const key = this._poolKeyHash[renderTexture.uid];\n\n        this._texturePool[key].push(renderTexture);\n    }\n\n    /**\n     * Clears the pool.\n     * @param destroyTextures - Destroy all stored textures.\n     */\n    public clear(destroyTextures?: boolean): void\n    {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures)\n        {\n            for (const i in this._texturePool)\n            {\n                const textures = this._texturePool[i];\n\n                if (textures)\n                {\n                    for (let j = 0; j < textures.length; j++)\n                    {\n                        textures[j].destroy(true);\n                    }\n                }\n            }\n        }\n\n        this._texturePool = {};\n    }\n}\n\nexport const TexturePool = new TexturePoolClass();\n","\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n//# sourceMappingURL=localUniformBit.mjs.map\n","export const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n","import { DOMAdapter } from '../../../../environment/adapter.mjs';\nimport { nextPow2 } from '../../../../maths/misc/pow2.mjs';\n\n\"use strict\";\nclass CanvasPoolClass {\n  constructor(canvasOptions) {\n    this._canvasPool = /* @__PURE__ */ Object.create(null);\n    this.canvasOptions = canvasOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   */\n  _createCanvasAndContext(pixelWidth, pixelHeight) {\n    const canvas = DOMAdapter.get().createCanvas();\n    canvas.width = pixelWidth;\n    canvas.height = pixelHeight;\n    const context = canvas.getContext(\"2d\");\n    return { canvas, context };\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param minWidth - The minimum width of the render texture.\n   * @param minHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @returns The new render texture.\n   */\n  getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {\n    minWidth = Math.ceil(minWidth * resolution - 1e-6);\n    minHeight = Math.ceil(minHeight * resolution - 1e-6);\n    minWidth = nextPow2(minWidth);\n    minHeight = nextPow2(minHeight);\n    const key = (minWidth << 17) + (minHeight << 1);\n    if (!this._canvasPool[key]) {\n      this._canvasPool[key] = [];\n    }\n    let canvasAndContext = this._canvasPool[key].pop();\n    if (!canvasAndContext) {\n      canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n    }\n    return canvasAndContext;\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param canvasAndContext\n   */\n  returnCanvasAndContext(canvasAndContext) {\n    const canvas = canvasAndContext.canvas;\n    const { width, height } = canvas;\n    const key = (width << 17) + (height << 1);\n    canvasAndContext.context.clearRect(0, 0, width, height);\n    this._canvasPool[key].push(canvasAndContext);\n  }\n  clear() {\n    this._canvasPool = {};\n  }\n}\nconst CanvasPool = new CanvasPoolClass();\n\nexport { CanvasPool, CanvasPoolClass };\n//# sourceMappingURL=CanvasPool.mjs.map\n","import { DOMAdapter } from '../../../../environment/adapter';\nimport { nextPow2 } from '../../../../maths/misc/pow2';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\n\nexport interface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in\n * @name CanvasPool\n * @memberof rendering\n */\nexport class CanvasPoolClass\n{\n    public canvasOptions: ICanvasRenderingContext2DSettings;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n    private _canvasPool: {[x in string | number]: CanvasAndContext[]};\n\n    constructor(canvasOptions?: ICanvasRenderingContext2DSettings)\n    {\n        this._canvasPool = Object.create(null);\n        this.canvasOptions = canvasOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     */\n    private _createCanvasAndContext(pixelWidth: number, pixelHeight: number): CanvasAndContext\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = pixelWidth;\n        canvas.height = pixelHeight;\n\n        const context = canvas.getContext('2d');\n\n        return { canvas, context };\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param minWidth - The minimum width of the render texture.\n     * @param minHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @returns The new render texture.\n     */\n    public getOptimalCanvasAndContext(minWidth: number, minHeight: number, resolution = 1): CanvasAndContext\n    {\n        minWidth = Math.ceil((minWidth * resolution) - 1e-6);\n        minHeight = Math.ceil((minHeight * resolution) - 1e-6);\n        minWidth = nextPow2(minWidth);\n        minHeight = nextPow2(minHeight);\n\n        const key = (minWidth << 17) + (minHeight << 1);\n\n        if (!this._canvasPool[key])\n        {\n            this._canvasPool[key] = [];\n        }\n\n        let canvasAndContext = this._canvasPool[key].pop();\n\n        if (!canvasAndContext)\n        {\n            canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n        }\n\n        return canvasAndContext;\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param canvasAndContext\n     */\n    public returnCanvasAndContext(canvasAndContext: CanvasAndContext): void\n    {\n        const canvas = canvasAndContext.canvas;\n        const { width, height } = canvas;\n\n        const key = (width << 17) + (height << 1);\n\n        canvasAndContext.context.clearRect(0, 0, width, height);\n\n        this._canvasPool[key].push(canvasAndContext);\n    }\n\n    public clear(): void\n    {\n        this._canvasPool = {};\n    }\n}\n\nexport const CanvasPool = new CanvasPoolClass();\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","parcelRequire","$parcel$global","globalThis","parcelRegister","register","module","exports","$f68a91b4254cec58$export$7254cc27399e90bd","$f68a91b4254cec58$var$blendModeIds","normal","add","multiply","screen","overlay","erase","min","max","$f68a91b4254cec58$var$_State","_State","constructor","data","blendMode","polygonOffset","blend","depthMask","value","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","toString","for2d","state","default2d","$67025a23fd381e5c$export$2c68e848c5b81f5","abgr","out","offset","alpha","$745046e2c487719c$export$fe4bdc7069ee0b9c","batcherName","attributeSize","indexSize","packAsQuad","roundPixels","_attributeStart","_batcher","_batch","renderable","groupBlendMode","color","groupColorAlpha","reset","texture","bounds","$0b9fa50ced13ccd0$export$686d8ddcd5ee6cd2","$NbSCN","$iA5fe","$bLlTJ","$0b9fa50ced13ccd0$var$count","textureOptions","_poolKeyHash","create","_texturePool","enableFullScreen","createTexture","pixelWidth","pixelHeight","antialias","textureSource","TextureSource","width","height","resolution","autoGarbageCollect","Texture","source","label","getOptimalTexture","frameWidth","frameHeight","po2Width","Math","ceil","po2Height","key","nextPow2","pop","_resolution","frame","x","y","updateUvs","uid","getSameSizeTexture","returnTexture","renderTexture","push","clear","destroyTextures","i","textures","j","length","destroy","$0f993a3eb7a96f7d$export$1723ac05bd5e9336","$0f993a3eb7a96f7d$export$adb0f80794f644d9","$0f993a3eb7a96f7d$export$36099520d0a716a","name","vertex","header","main","end","replace","$cb3b5b020b2ab749$export$e56d0a06781accc9","$iCGeI","canvasOptions","_canvasPool","_createCanvasAndContext","canvas","DOMAdapter","createCanvas","context","getContext","getOptimalCanvasAndContext","minWidth","minHeight","canvasAndContext","returnCanvasAndContext","clearRect"],"version":3,"file":"webworkerAll.aa8dbea8.js.map"}